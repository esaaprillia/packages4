From 2542ef3b6dcac86059f98a8e84ef6a1f10290348 Mon Sep 17 00:00:00 2001
From: esaaprillia <esaapriliasalsabila@gmail.com>
Date: Mon, 3 Feb 2025 17:43:27 +0800
Subject: [PATCH] Update setup_configure.py

---
 setup_configure.py | 104 ---------------------------------------------
 1 file changed, 104 deletions(-)

diff --git a/setup_configure.py b/setup_configure.py
index 3c5fe0d..e0f99bd 100644
--- a/setup_configure.py
+++ b/setup_configure.py
@@ -81,41 +81,6 @@ def __init__(self, hdf5_includedirs, hdf5_libdirs, hdf5_define_macros,
             self.msmpi_inc_dirs = []
             self.msmpi_lib_dirs = []
 
-    @classmethod
-    def from_env(cls):
-        mpi = mpi_enabled()
-        h5_inc, h5_lib, h5_macros = cls._find_hdf5_compiler_settings(mpi)
-
-        h5_version_s = os.environ.get('HDF5_VERSION')
-        h5py_ros3 = os.environ.get('H5PY_ROS3')
-        h5py_direct_vfd = os.environ.get('H5PY_DIRECT_VFD')
-
-        if h5_version_s and not mpi and h5py_ros3 and h5py_direct_vfd:
-            # if we know config, don't use wrapper, it may not be supported
-            return cls(
-                h5_inc, h5_lib, h5_macros, validate_version(h5_version_s), mpi,
-                h5py_ros3 == '1', h5py_direct_vfd == '1')
-
-        h5_wrapper = HDF5LibWrapper(h5_lib)
-        if h5_version_s:
-            h5_version = validate_version(h5_version_s)
-        else:
-            h5_version = h5_wrapper.autodetect_version()
-            if mpi and not h5_wrapper.has_mpi_support():
-                raise RuntimeError("MPI support not detected")
-
-        if h5py_ros3:
-            ros3 = h5py_ros3 == '1'
-        else:
-            ros3 = h5_wrapper.has_ros3_support()
-
-        if h5py_direct_vfd:
-            direct_vfd = h5py_direct_vfd == '1'
-        else:
-            direct_vfd = h5_wrapper.has_direct_vfd_support()
-
-        return cls(h5_inc, h5_lib, h5_macros, h5_version, mpi, ros3, direct_vfd)
-
     @staticmethod
     def _find_hdf5_compiler_settings(mpi=False):
         """Get compiler settings from environment or pkgconfig.
@@ -226,75 +191,6 @@ def fmt_dirs(l):
         print('*' * 80)
 
 
-class HDF5LibWrapper:
-
-    def __init__(self, libdirs):
-        self._load_hdf5_lib(libdirs)
-
-    def _load_hdf5_lib(self, libdirs):
-        """
-        Detect and load the HDF5 library.
-
-        Raises an exception if anything goes wrong.
-
-        libdirs: the library paths to search for the library
-        """
-        import ctypes
-
-        # extra keyword args to pass to LoadLibrary
-        load_kw = {}
-        if sys.platform.startswith('darwin'):
-            default_path = 'libhdf5.dylib'
-            regexp = re.compile(r'^libhdf5.dylib')
-        elif sys.platform.startswith('win'):
-            if 'MSC' in sys.version:
-                default_path = 'hdf5.dll'
-                regexp = re.compile(r'^hdf5.dll')
-            else:
-                default_path = 'libhdf5-0.dll'
-                regexp = re.compile(r'^libhdf5-[0-9].dll')
-            # To overcome "difficulty" loading the library on windows
-            # https://bugs.python.org/issue42114
-            load_kw['winmode'] = 0
-        elif sys.platform.startswith('cygwin'):
-            default_path = 'cyghdf5-200.dll'
-            regexp = re.compile(r'^cyghdf5-\d+.dll$')
-        else:
-            default_path = 'libhdf5.so'
-            regexp = re.compile(r'^libhdf5.so')
-
-        path = None
-        for d in libdirs:
-            try:
-                candidates = [x for x in os.listdir(d) if regexp.match(x)]
-            except Exception:
-                continue   # Skip invalid entries
-
-            if len(candidates) != 0:
-                candidates.sort(key=lambda x: len(x))   # Prefer libfoo.so to libfoo.so.X.Y.Z
-                path = op.abspath(op.join(d, candidates[0]))
-                break
-
-        if path is None:
-            path = default_path
-
-        print("Loading library to get build settings and version:", path)
-
-        self._lib_path = path
-
-        if op.isabs(path) and not op.exists(path):
-            raise FileNotFoundError(f"{path} is missing")
-
-        try:
-            lib = ctypes.CDLL(path, **load_kw)
-        except Exception:
-            print("error: Unable to load dependency HDF5, make sure HDF5 is installed properly")
-            print(f"on {sys.platform=} with {platform.machine()=}")
-            print("Library dirs checked:", libdirs)
-            raise
-
-        self._lib = lib
-
     def autodetect_version(self):
         """
         Detect the current version of HDF5, and return X.Y.Z version string.
